(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{285:function(o,t,_){"use strict";_.r(t);var e=_(14),v=Object(e.a)({},(function(){var o=this,t=o._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[t("h2",{attrs:{id:"原型和原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[o._v("#")]),o._v(" 原型和原型链")]),o._v(" "),t("h3",{attrs:{id:"函数对象-和-普通对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数对象-和-普通对象"}},[o._v("#")]),o._v(" 函数对象 和 普通对象")]),o._v(" "),t("p",[o._v("想要理解这两者之间的联系，首先得明确Javascript里面"),t("strong",[o._v("对象")]),o._v("，在Javascript，我们可以把对象分为 "),t("strong",[o._v("普通对象")]),o._v(" 和 "),t("strong",[o._v("函数对象")]),o._v("，"),t("strong",[o._v("Object")]),o._v("和"),t("strong",[o._v("Function")]),o._v("就是Javascript中自带的两个函数对象。\n而函数对象就是一个纯函数，本质上是Javascript在模拟"),t("strong",[o._v("类")]),o._v("。")]),o._v(" "),t("p",[o._v("让我们举例说明，什么是普通对象，什么是函数对象。")]),o._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[o._v("  function fn1 () {}\n  const fn2 = function () {}\n  const fn3 = new Function() {}\n\n  const obj1 = {}\n  const obj2 = new Object()\n  const obj3 = new fn1()\n")])])]),t("p",[o._v("上述例子中，obj1，obj2，obj3为普通对象，fn1，fn2，fn3为函数对象，\n如何区分，只需要记住：")]),o._v(" "),t("blockquote",[t("p",[o._v("所有的Function的实例都是函数对象，其他的都是普通对象。")])]),o._v(" "),t("p",[t("strong",[o._v("tips：")]),o._v(" 对象本身的实现还是要依靠"),t("strong",[o._v("构造函数")]),o._v("，那么"),t("strong",[o._v("原型链")]),o._v("到底是用来干什么的呢？原型链的目的，是为了"),t("strong",[o._v("继承")])]),o._v(" "),t("h3",{attrs:{id:"prototype-和-proto"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prototype-和-proto"}},[o._v("#")]),o._v(" prototype 和 "),t("strong",[o._v("proto")])]),o._v(" "),t("p",[o._v("并不是所有的对象都有"),t("code",[o._v("prototype")]),o._v(" 和 "),t("code",[o._v("__proto__")]),o._v("，\n首先我们先给出结论：")]),o._v(" "),t("ul",[t("li",[o._v("只有函数对象才有"),t("code",[o._v("prototype")]),o._v("；")]),o._v(" "),t("li",[t("code",[o._v("prototype")]),o._v("和"),t("code",[o._v("__proto__")]),o._v("都是Javascript再定义一个函数或者对象时"),t("code",[o._v("自动创建")]),o._v("的"),t("code",[o._v("预定义属性")])])]),o._v(" "),t("p",[o._v("所以，最终结论是")]),o._v(" "),t("ul",[t("li",[t("code",[o._v("prototype")]),o._v(" 被实例的 "),t("code",[o._v("__proto__")]),o._v(" 所指向（被动）")]),o._v(" "),t("li",[o._v("实例的 "),t("code",[o._v("__proto__")]),o._v(" 指向构造函数的 "),t("code",[o._v("prototype")]),o._v("（主动）")])]),o._v(" "),t("p",[o._v("即以下代码")]),o._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[o._v("  fn.__proto__ === Function.prototype\n  obj.__proto__ === Object.prototype\n")])])]),t("p",[o._v("那么？"),t("code",[o._v("fn.prototype.__proto__")]),o._v(" 指向什么？")]),o._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[o._v("  fn.prototype.__proto__ === Object.prototype\n")])])]),t("p",[o._v("最终我们可以得到以下结论：\n普通对象就是 "),t("strong",[o._v("函数对象")]),o._v(" 实例化（new）得到的，而一个实例不能再次实例化，所以就不会让另一个对象的"),t("code",[o._v("__proto__")]),o._v(" 指向它的的 "),t("code",[o._v("prototype")]),o._v("；我们还可以得出，"),t("code",[o._v("fn.prototype")]),o._v("就是一个普通对象，他也没有"),t("code",[o._v("prototype")]),o._v("属性。")]),o._v(" "),t("h3",{attrs:{id:"原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[o._v("#")]),o._v(" 原型链")]),o._v(" "),t("p",[o._v("先上代码")]),o._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[o._v("  const Person = function (name, age) {\n    this.name = name\n    this.age = age\n  }\n\n  Person.prototype.getName = () => {\n    return this.name\n  }\n\n  Person.prototype.getAge = () => {\n    return this.age\n  }\n\n  const jovi = new Person('jovi', 18)\n  console.log(jovi)\n  console.log(jovi.getName(), jovi.getAge())\n")])])]),t("p",[o._v("代码解读：本质就是原型继承的实现过程。\n"),t("code",[o._v("jovi.__proto__")]),o._v(" === "),t("code",[o._v("Person.prototype")]),o._v("\n在执行 jovi.getName()时，由于在jovi这个对象中，找不到此方法，就会朝着原型链向上查找，即通过 "),t("code",[o._v("__proto__")]),o._v("向上查找，并在"),t("code",[o._v("Person.prototype")]),o._v("中找到该方法，执行并得到结果。")]),o._v(" "),t("p",[o._v("最终结论：当访问一个对象的某个属性或者方法时，若在当前对象上找不到，则会尝试访问"),t("code",[o._v("obj.__proto__")]),o._v("，也就是访问构造函数的原型属性，即"),t("code",[o._v("objConstructor.prototype")]),o._v("，若仍然找不到，\n则会继续向上访问 "),t("code",[o._v("objConstructor.prototype.__proto__")]),o._v(",像这样依次访问，若在某一刻找到，则立即返回值并停止对原型链的搜索，若找不到，则返回"),t("code",[o._v("undefined")]),o._v("。")]),o._v(" "),t("p",[o._v("tips：原型链的尽头是 "),t("code",[o._v("null")]),o._v("，"),t("code",[o._v("__proto__")]),o._v(" 是原型链查找的起点。")])])}),[],!1,null,null,null);t.default=v.exports}}]);