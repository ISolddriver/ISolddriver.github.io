(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{280:function(e,t,a){"use strict";a.r(t);var r=a(14),v=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"vue路由守卫"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue路由守卫"}},[e._v("#")]),e._v(" vue路由守卫")]),e._v(" "),t("h3",{attrs:{id:"全局守卫"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局守卫"}},[e._v("#")]),e._v(" 全局守卫")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("全局前置守卫(beforeEach)")]),e._v("：在路由跳转前执行，一般用于登录验证、页面权限控制等。")]),e._v(" "),t("li",[t("code",[e._v("全局解析守卫(beforeResolve)")]),e._v("：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。")]),e._v(" "),t("li",[t("code",[e._v("全局后置钩子(afterEach)")]),e._v("：在路由跳转后执行，一般用于页面title的修改、页面访问统计等。通过调用此方法，不接收 next 函数，也不能改变导航。")])]),e._v(" "),t("h3",{attrs:{id:"路由独享守卫"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由独享守卫"}},[e._v("#")]),e._v(" 路由独享守卫")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("beforeEnter")]),e._v("：在路由配置中定义，只在进入该路由时触发。")])]),e._v(" "),t("h3",{attrs:{id:"组件内守卫"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件内守卫"}},[e._v("#")]),e._v(" 组件内守卫")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("beforeRouteEnter")]),e._v("：在渲染该组件的对应路由被 confirm 前调用，不能获取组件实例 "),t("code",[e._v("this")]),e._v("，因为当守卫执行前，组件实例还没被创建。")]),e._v(" "),t("li",[t("code",[e._v("beforeRouteUpdate")]),e._v("：在当前路由改变，但是该组件被复用时调用。")]),e._v(" "),t("li",[t("code",[e._v("beforeRouteLeave")]),e._v("：导航离开该组件的对应路由时调用，用于组件销毁前的清理工作。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);