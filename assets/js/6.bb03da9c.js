(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{273:function(v,t,_){v.exports=_.p+"assets/img/diff1.a4ed7085.png"},274:function(v,t,_){v.exports=_.p+"assets/img/diff.8d9e5abe.png"},298:function(v,t,_){"use strict";_.r(t);var i=_(14),e=Object(i.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"vue-中-diff算法实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-中-diff算法实现原理"}},[v._v("#")]),v._v(" Vue 中 Diff算法实现原理")]),v._v(" "),t("h3",{attrs:{id:"vue2-的-diff-算法实现原理是"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2-的-diff-算法实现原理是"}},[v._v("#")]),v._v(" vue2 的 diff 算法实现原理是")]),v._v(" "),t("p",[t("code",[v._v("同层比较；双端比较；在比较过程中，循环向中间靠拢")]),v._v("。"),t("br")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("同层比较，只会在同层比较，不会跨层比较。"),t("br"),v._v(" "),t("img",{attrs:{src:_(273),alt:"diff"}})])]),v._v(" "),t("li",[t("p",[v._v("双端比较，在比较过程中，循环向中间靠拢"),t("br"),v._v(" "),t("img",{attrs:{src:_(274),alt:"diff1"}})])])]),v._v(" "),t("ul",[t("li",[v._v("同时从新旧节点的头尾开始比较")]),v._v(" "),t("li",[v._v("如果头部或者尾部的节点相同，则复用节点，指针向中间靠拢。")]),v._v(" "),t("li",[v._v("如果头部或者尾部的节点不同，则尝试在旧节点中找到与新节点相同的节点，找到则复用节点，指针向中间靠拢。找不到则删除旧节点，添加新节点。")])]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[t("code",[v._v("key")]),v._v("的作用")])]),v._v(" "),t("ul",[t("li",[v._v("通过为每一个节点设置唯一的"),t("code",[v._v("key")]),v._v("，可以更准确的识别出那些节点可以复用，减少 DOM 操作，提高新能。")])]),v._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[v._v("patch函数")])]),v._v(" "),t("ul",[t("li",[v._v("diff 算法最终通过 "),t("code",[v._v("patch")]),v._v("函数将差异应用到真实的 DOM 中。它的参数为（oldVnode, vnode, hydrating, removeOnly），作用如下：")]),v._v(" "),t("li",[v._v("没有新的节点，则直接触发旧节点的 destroy钩子函数，删除旧节点。")]),v._v(" "),t("li",[v._v("没有旧节点，说明是页面新建，则直接触发新节点的 create 钩子函数，创建新节点。")]),v._v(" "),t("li",[v._v("新节点和旧节点相同，通过 sameVnode 函数判断，如果相同则触发 patchVnode 函数，对新旧节点的子节点精细化比较。")]),v._v(" "),t("li",[v._v("新节点和旧节点不同，则根据新节点的类型创建对应的 DOM 节点，并删除旧节点。")])]),v._v(" "),t("blockquote",[t("p",[v._v("patchVnode 函数的作用，是对新旧节点的子节点进行 diff 比较和更新。")])]),v._v(" "),t("h3",{attrs:{id:"vue3-的-diff-算法的优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-的-diff-算法的优化"}},[v._v("#")]),v._v(" vue3 的 diff 算法的优化")]),v._v(" "),t("ol",[t("li",[v._v("静态提升：将静态内容提升到渲染函数外部，避免重复生成静态节点的开销，比较节点时，不需要比较静态节点。")]),v._v(" "),t("li",[v._v("PatchFlag-动态标记：为动态的节点打上标记，可以直接定位到需要更新的节点，无需遍历整个节点树。")]),v._v(" "),t("li",[v._v("缓存事件处理函数：将事件处理函数缓存起来，避免每次更新时重新生成。")]),v._v(" "),t("li",[v._v("Fragments：支持多个根节点的组件，更新时只需要更新根节点，无需遍历整个节点树。")]),v._v(" "),t("li",[v._v("Block：将多个节点打包成一个块，在更新时，只需要更新块内的节点，无需遍历整个节点树。")]),v._v(" "),t("li",[v._v("优化 diff 算法：使用最长递增子序列算法，减少了DOM移动操作。")])]),v._v(" "),t("h2",{attrs:{id:"react-中-diff算法实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-中-diff算法实现原理"}},[v._v("#")]),v._v(" React 中 Diff算法实现原理")]),v._v(" "),t("p",[t("strong",[v._v("分为四个阶段")])]),v._v(" "),t("ol",[t("li",[v._v("树的 Diff：同层比较，递归比较节点，如果节点类型不同，则直接替换，如果节点类型相同，则更新节点的属性并递归子节点。")]),v._v(" "),t("li",[v._v("列表的 Diff：采用双端比较 + key优化，减少不必要的 DOM 操作。")]),v._v(" "),t("li",[v._v("key 的作用：精准识别出哪些节点可以复用，减少不必要的 DOM 操作。")]),v._v(" "),t("li",[v._v("Fiber 优化：增量渲染，将渲染任务拆分成多个小任务，分批执行，避免阻塞主线程；优先级调度，根据任务的优先级，优先执行高优先级的任务。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);